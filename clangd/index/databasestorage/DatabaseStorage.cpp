//===--- DatabaseStorage.cpp - Dynamic on-disk symbol index. ------C++-*-===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===--------------------------------------------------------------------===//

#include "DatabaseStorage.h"
#include "DBTrigram.h"
#include "FuzzyMatch.h"
#include "Logger.h"
#include "Quality.h"
#include "RecordIDIterator.h"
#include "RecordIDPostingList.h"
#include "URI.h"
#include "index/Merge.h"
#include "llvm/ADT/StringExtras.h"
#include "llvm/Support/BinaryByteStream.h"
#include "llvm/Support/BinaryStreamReader.h"
#include "llvm/Support/BinaryStreamWriter.h"
#include "llvm/Support/FileSystem.h"
#include "llvm/Support/SHA1.h"

namespace clang {
namespace clangd {
namespace dbindex {

/// \brief A type that is 8 bytes in size containing ID generated by hash
/// function.
using HashedID = std::array<uint8_t, 8>;

/// \brief Metadata information for a file
struct FileInfo {
  FileDigest Digest;
};

/// \brief Query Tree Iterator implementation for std::vector
class VectorIterator : public Iterator {
public:
  VectorIterator(llvm::ArrayRef<DocID> V) : IDs(V), It(V.begin()) {}

  /// Check if the vector iterator reaches the end of vector
  bool reachedEnd() const override { return It == IDs.end(); }

  /// Advance the vector iterator to the next element
  void advance() override {
    assert(!reachedEnd() && "Vector iterator can't advance() at the end.");
    It++;
  }

  /// Advance the vector iterator to the next element with given ID
  void advanceTo(DocID ID) override {
    assert(!reachedEnd() && "Vector iterator can't advanceTo() at the end.");
    llvm::bsearch(It, IDs.end(), [&ID](RecordID I) { return I >= ID; });
  }

  /// Return the DocID under the vector iterator to the current element
  DocID peek() const override {
    assert(!reachedEnd() && "Vector iterator can't peek() at the end.");
    return *It;
  }

  float consume() override {
    assert(!reachedEnd() && "Vector iterator can't consume() at the end.");
    return 1;
  }

  size_t estimateSize() const override { return IDs.size(); }

private:
  llvm::raw_ostream &dump(llvm::raw_ostream &OS) const override {
    OS << '[';
    const char *Sep = "";
    for (const DocID Doc : IDs) {
      OS << Sep << Doc;
      Sep = " ";
    }
    return OS << ']';
  }

  llvm::ArrayRef<DocID> IDs;
  decltype(IDs)::iterator It;
};

/// Names for allocators and databases
const char *LMDBIndex::RECORDID_ALLOCATOR_RECORDS = "IDAllocator for records";
const char *LMDBIndex::DB_RECORDS = "Records";
const char *LMDBIndex::DB_FILEPATH_INFO = "File Path Information";
const char *LMDBIndex::DB_FILEID_TO_SYMBOL_RECS = "FileID to Symbol records";
const char *LMDBIndex::DB_FILEID_TO_REF_RECS = "FileID to Ref records";
const char *LMDBIndex::DB_SYMBOLID_TO_SYMBOL_RECS =
    "SymbolID to Symbol records";
const char *LMDBIndex::DB_SYMBOLID_TO_REF_RECS = "SymbolID to Ref records";
const char *LMDBIndex::DB_SYMBOLID_TO_SYMBOLS = "SymbolID to Symbols";
const char *LMDBIndex::DB_TRIGRAM_TO_SYMBOLID = "Trigram to SymbolID";
const char *LMDBIndex::DB_SCOPE_TO_SYMBOLID = "Scope to SymbolID";

/// The byte order of serialization for integers
static constexpr llvm::support::endianness SerializeEndianness =
    llvm::support::endianness::little;

/// Make HashedID from given string
static HashedID makeHashedID(llvm::StringRef S) {
  HashedID ID;
  auto Hash = llvm::SHA1::hash(llvm::arrayRefFromStringRef(S));
  memcpy(ID.data(), Hash.data(), ID.size());
  return ID;
}

/// Format a given array to HashedID
static HashedID readHashedID(llvm::ArrayRef<uint8_t> A) {
  HashedID ID;
  memcpy(ID.data(), A.data(), ID.size());
  return ID;
}

/// Make file RecordID key from RecordID
static std::array<uint8_t, sizeof(RecordID)> makeRecordIDKey(RecordID RecID) {
  std::array<uint8_t, sizeof(RecordID)> A;
  llvm::support::endian::write(A.data(), RecID,
                               llvm::support::endianness::native);
  return A;
}

/// Format a given array to HashedID
static RecordID readRecordIDKey(llvm::ArrayRef<uint8_t> A) {
  return llvm::support::endian::read<RecordID>(
      A.data(), llvm::support::endianness::native);
}

/// We explicitly disallow failing for BinaryStreamError(),
/// as this indicates possible internal corruption of states
/// that cannot be recovered, such as tampering of database.
///
/// XXX: Should also consider more peaceful failing due to
/// schema upgrade.
static void handleBinaryStreamErrors(llvm::Error E) {
  llvm::handleAllErrors(
      std::move(E),
      [](std::unique_ptr<llvm::BinaryStreamError> E) -> llvm::Error {
        E->log(llvm::outs());
        return llvm::Error(std::move(E));
      });
}

/// Serialize Ref to byte stream
static void serialize(llvm::BinaryStreamWriter &SW, SymbolID ID) {
  handleBinaryStreamErrors(SW.writeFixedString(ID.raw()));
}

/// Deserialize Ref from byte stream
static void deserialize(llvm::BinaryStreamReader &SR, SymbolID &ID) {
  llvm::StringRef S;
  handleBinaryStreamErrors(SR.readFixedString(S, SymbolID::RawSize));
  ID = SymbolID::fromRaw(S);
}

/// Serialize SymbolLocation to byte stream
static void serialize(llvm::BinaryStreamWriter &SW, const SymbolLocation &Loc) {
  handleBinaryStreamErrors(SW.writeCString(Loc.FileURI));
  for (auto &Pos : {Loc.Start, Loc.End}) {
    handleBinaryStreamErrors(SW.writeInteger(Pos.line()));
    handleBinaryStreamErrors(SW.writeInteger(Pos.column()));
  }
}

/// Deserialize SymbolLocation from byte stream
static void deserialize(llvm::BinaryStreamReader &SR, SymbolLocation &Loc) {
  llvm::StringRef FileURI;
  handleBinaryStreamErrors(SR.readCString(FileURI));
  Loc.FileURI = FileURI.data();
  for (auto Pos : {&Loc.Start, &Loc.End}) {
    uint32_t Line, Column;
    handleBinaryStreamErrors(SR.readInteger(Line));
    handleBinaryStreamErrors(SR.readInteger(Column));
    Pos->setLine(Line);
    Pos->setColumn(Column);
  }
}

/// Serialize Symbol::IncludeHeaderWithReferences to byte stream
static void serialize(llvm::BinaryStreamWriter &SW,
                      const Symbol::IncludeHeaderWithReferences &Include) {
  handleBinaryStreamErrors(SW.writeCString(Include.IncludeHeader));
  handleBinaryStreamErrors(SW.writeInteger(Include.References));
}

/// Deserialize Symbol::IncludeHeaderWithReferences from byte stream
static void deserialize(llvm::BinaryStreamReader &SR,
                        Symbol::IncludeHeaderWithReferences &Include) {
  handleBinaryStreamErrors(SR.readCString(Include.IncludeHeader));
  handleBinaryStreamErrors(SR.readInteger(Include.References));
}

/// Serialize Symbol to byte stream
static void serialize(llvm::BinaryStreamWriter &SW, const Symbol &Sym) {
  serialize(SW, Sym.ID);
  handleBinaryStreamErrors(SW.writeEnum(Sym.SymInfo.Kind));
  handleBinaryStreamErrors(SW.writeEnum(Sym.SymInfo.Lang));
  handleBinaryStreamErrors(SW.writeCString(Sym.Name));
  handleBinaryStreamErrors(SW.writeCString(Sym.Scope));
  serialize(SW, Sym.Definition);
  serialize(SW, Sym.CanonicalDeclaration);
  handleBinaryStreamErrors(SW.writeInteger(Sym.References));
  handleBinaryStreamErrors(SW.writeEnum(Sym.Origin));
  handleBinaryStreamErrors(SW.writeCString(Sym.Signature));
  handleBinaryStreamErrors(SW.writeCString(Sym.CompletionSnippetSuffix));
  handleBinaryStreamErrors(SW.writeCString(Sym.Documentation));
  handleBinaryStreamErrors(SW.writeCString(Sym.ReturnType));
  handleBinaryStreamErrors(SW.writeCString(Sym.Type));
  handleBinaryStreamErrors(SW.writeEnum(Sym.Flags));
  handleBinaryStreamErrors(SW.writeInteger(Sym.IncludeHeaders.size()));
  for (const auto &I : Sym.IncludeHeaders)
    serialize(SW, I);
}

/// Deserialize Symbol from byte stream
static void deserialize(llvm::BinaryStreamReader &SR, Symbol &Sym) {
  deserialize(SR, Sym.ID);
  handleBinaryStreamErrors(SR.readEnum(Sym.SymInfo.Kind));
  handleBinaryStreamErrors(SR.readEnum(Sym.SymInfo.Lang));
  handleBinaryStreamErrors(SR.readCString(Sym.Name));
  handleBinaryStreamErrors(SR.readCString(Sym.Scope));
  deserialize(SR, Sym.Definition);
  deserialize(SR, Sym.CanonicalDeclaration);
  handleBinaryStreamErrors(SR.readInteger(Sym.References));
  handleBinaryStreamErrors(SR.readEnum(Sym.Origin));
  handleBinaryStreamErrors(SR.readCString(Sym.Signature));
  handleBinaryStreamErrors(SR.readCString(Sym.CompletionSnippetSuffix));
  handleBinaryStreamErrors(SR.readCString(Sym.Documentation));
  handleBinaryStreamErrors(SR.readCString(Sym.ReturnType));
  handleBinaryStreamErrors(SR.readCString(Sym.Type));
  handleBinaryStreamErrors(SR.readEnum(Sym.Flags));
  size_t Size;
  handleBinaryStreamErrors(SR.readInteger(Size));
  for (size_t i = 0; i < Size; ++i) {
    Symbol::IncludeHeaderWithReferences I;
    deserialize(SR, I);
    Sym.IncludeHeaders.push_back(I);
  }
}

/// Serialize Ref to byte stream
static void serialize(llvm::BinaryStreamWriter &SW, const Ref &Ref) {
  serialize(SW, Ref.Location);
  handleBinaryStreamErrors(SW.writeEnum(Ref.Kind));
}

/// Deserialize Ref from byte stream
static void deserialize(llvm::BinaryStreamReader &SR, Ref &Ref) {
  deserialize(SR, Ref.Location);
  handleBinaryStreamErrors(SR.readEnum(Ref.Kind));
}

/// Serialize IncludeGraphNode to byte stream
static void serialize(llvm::BinaryStreamWriter &SW,
                      const IncludeGraphNode &IGN) {
  handleBinaryStreamErrors(SW.writeInteger(IGN.IsTU));
  handleBinaryStreamErrors(SW.writeCString(IGN.URI));
  handleBinaryStreamErrors(SW.writeFixedString(llvm::toStringRef(IGN.Digest)));
  handleBinaryStreamErrors(SW.writeInteger(IGN.DirectIncludes.size()));
  for (auto &I : IGN.DirectIncludes)
    handleBinaryStreamErrors(SW.writeCString(I));
}

/// Deserialize IncludeGraphNode from byte stream
static void deserialize(llvm::BinaryStreamReader &SR, IncludeGraphNode &IGN) {
  handleBinaryStreamErrors(SR.readInteger(IGN.IsTU));
  handleBinaryStreamErrors(SR.readCString(IGN.URI));
  llvm::StringRef Digest;
  handleBinaryStreamErrors(SR.readFixedString(Digest, IGN.Digest.size()));
  llvm::copy(llvm::make_range(Digest.begin(), Digest.end()),
             IGN.Digest.begin());
  size_t Size;
  handleBinaryStreamErrors(SR.readInteger(Size));
  IGN.DirectIncludes.resize(Size);
  for (auto &I : IGN.DirectIncludes)
    handleBinaryStreamErrors(SR.readCString(I));
}

/// Serialize FileInfo to byte stream
static void serialize(llvm::BinaryStreamWriter &SW, const FileInfo &FI) {
  handleBinaryStreamErrors(SW.writeBytes(FI.Digest));
}

/// Deserialize FileInfo from byte stream
static void deserialize(llvm::BinaryStreamReader &SR, FileInfo &FI) {
  llvm::ArrayRef<uint8_t> Digest;
  handleBinaryStreamErrors(SR.readBytes(Digest, FI.Digest.size()));
  llvm::copy(llvm::make_range(Digest.begin(), Digest.end()), FI.Digest.begin());
}

/// Serialize Symbol to byte stream and return as std::string
static std::string serializeSymbol(const Symbol &Sym) {
  llvm::AppendingBinaryByteStream BS(SerializeEndianness);
  llvm::BinaryStreamWriter SW(BS);
  serialize(SW, Sym);
  handleBinaryStreamErrors(BS.commit());
  return toStringRef(BS.data());
}

/// Deserialize Symbol from byte stream
static Symbol deserializeSymbol(llvm::StringRef Buf) {
  Symbol Sym;
  llvm::BinaryStreamReader SR(Buf, SerializeEndianness);
  deserialize(SR, Sym);
  return Sym;
}

/// Serialize Ref to byte stream
static std::string serializeSymbolIDRef(SymbolID ID, const Ref &R) {
  llvm::AppendingBinaryByteStream BS(SerializeEndianness);
  llvm::BinaryStreamWriter SW(BS);
  serialize(SW, ID);
  serialize(SW, R);
  handleBinaryStreamErrors(BS.commit());
  return toStringRef(BS.data());
}

/// Deserialize Ref from byte stream
static std::pair<SymbolID, Ref> deserializeSymbolIDRef(llvm::StringRef Buf) {
  SymbolID ID;
  Ref R;
  llvm::BinaryStreamReader SR(Buf, SerializeEndianness);
  deserialize(SR, ID);
  deserialize(SR, R);
  return std::make_pair(ID, R);
}

/// Serialize IncludeGraphNode to byte stream
static std::string serializeIncludeGraphNode(const IncludeGraphNode &IGN) {
  llvm::AppendingBinaryByteStream BS(SerializeEndianness);
  llvm::BinaryStreamWriter SW(BS);
  serialize(SW, IGN);
  handleBinaryStreamErrors(BS.commit());
  return toStringRef(BS.data());
}

/// Deserialize IncludeGraphNode from byte stream
static IncludeGraphNode deserializeIncludeGraphNode(llvm::StringRef Buf) {
  IncludeGraphNode IGN;
  llvm::BinaryStreamReader SR(Buf, SerializeEndianness);
  deserialize(SR, IGN);
  return IGN;
}

/// Serialize FileInfo to byte stream
static std::string serializeFileInfo(const FileInfo &FI) {
  llvm::AppendingBinaryByteStream BS(SerializeEndianness);
  llvm::BinaryStreamWriter SW(BS);
  serialize(SW, FI);
  handleBinaryStreamErrors(BS.commit());
  return toStringRef(BS.data());
}

/// Deserialize FileInfo from byte stream
static FileInfo deserializeFileInfo(llvm::StringRef Buf) {
  FileInfo FI;
  llvm::BinaryStreamReader SR(Buf, SerializeEndianness);
  deserialize(SR, FI);
  return FI;
}

/// Own \Sym by copying the strings inside to \p StringStore
static void OwnSymbol(Symbol &Sym, llvm::StringSaver &StringStore) {
  visitStrings(Sym, [&StringStore](llvm::StringRef &Str) {
    Str = StringStore.save(Str);
  });
}

/// \brief iterates all the records associated with a key. For \p Callback,
/// if true is returned the iteration will continue, otherwise the
/// iteration will stop
llvm::Error foreachRecordsUnderKey(
    lmdb::Txn &Txn, lmdb::DBI &DBI, llvm::ArrayRef<uint8_t> Key,
    llvm::function_ref<bool(const lmdb::Val &Data)> Callback) {
  lmdb::Cursor Cursor;
  {
    auto Expected = lmdb::Cursor::open(Txn, DBI);
    if (!Expected)
      return Expected.takeError();
    Cursor = std::move(*Expected);
  }
  // Begin enumeration of all the associated \p RecordIDs with given \p Key
  return Cursor.foreachKey(
      Key,
      [&](const lmdb::Val &, const lmdb::Val &Data) -> lmdb::IteratorControl {
        if (!Callback(Data))
          return lmdb::IteratorControl::Stop;
        return lmdb::IteratorControl::Continue;
      });
}

std::unique_ptr<LMDBIndex> LMDBIndex::open(PathRef Path) {
  // If the database environment directory exists we
  // do not need a new one
  if (llvm::sys::fs::create_directory(Path, true))
    return nullptr;
  llvm::Expected<lmdb::Env> Env = lmdb::Env::create();
  if (llvm::errorToBool(Env.takeError()))
    return nullptr;

  // The size of database is now 512G in maximum
  auto Err = Env->setMapsize(1ull << 39);
  if (llvm::errorToBool(std::move(Err)))
    return nullptr;
  // Now we need 10 databases for our use including 1 allocator
  Err = Env->setMaxDBs(10);
  if (llvm::errorToBool(std::move(Err)))
    return nullptr;
  // No metasync during open as we do not need durability
  Err = Env->open(Path, MDB_NOMETASYNC);
  if (llvm::errorToBool(std::move(Err)))
    return nullptr;

  // Now starts a transaction so that we can persist changes to database,
  // i.e. creation of ID allocators and databases
  llvm::Expected<lmdb::Txn> Txn = lmdb::Txn::begin(*Env);
  if (llvm::errorToBool(Txn.takeError()))
    return nullptr;

  llvm::Expected<RecordIDAllocator> IDAllocator =
      RecordIDAllocator::open(*Txn, LMDBIndex::RECORDID_ALLOCATOR_RECORDS);
  if (llvm::errorToBool(IDAllocator.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBIRecords =
      lmdb::DBI::open(*Txn, LMDBIndex::DB_RECORDS, MDB_CREATE | MDB_INTEGERKEY);
  if (llvm::errorToBool(DBIRecords.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBIFilePathToFileInfo = lmdb::DBI::open(
      *Txn, LMDBIndex::DB_FILEPATH_INFO, MDB_CREATE | MDB_DUPSORT);
  if (llvm::errorToBool(DBIFilePathToFileInfo.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBIFileIDToSymbolRecs =
      lmdb::DBI::open(*Txn, LMDBIndex::DB_FILEID_TO_SYMBOL_RECS,
                      MDB_CREATE | MDB_DUPSORT | MDB_INTEGERDUP);
  if (llvm::errorToBool(DBIFileIDToSymbolRecs.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBIFileIDToRefRecs =
      lmdb::DBI::open(*Txn, LMDBIndex::DB_FILEID_TO_REF_RECS,
                      MDB_CREATE | MDB_DUPSORT | MDB_INTEGERDUP);
  if (llvm::errorToBool(DBIFileIDToRefRecs.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBISymbolIDToSymbolRecords = lmdb::DBI::open(
      *Txn, LMDBIndex::DB_SYMBOLID_TO_SYMBOL_RECS, MDB_CREATE | MDB_DUPSORT);
  if (llvm::errorToBool(DBISymbolIDToSymbolRecords.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBISymbolIDToRefRecords = lmdb::DBI::open(
      *Txn, LMDBIndex::DB_SYMBOLID_TO_REF_RECS, MDB_CREATE | MDB_DUPSORT);
  if (llvm::errorToBool(DBISymbolIDToRefRecords.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBISymbolIDToSymbols =
      lmdb::DBI::open(*Txn, LMDBIndex::DB_SYMBOLID_TO_SYMBOLS, MDB_CREATE);
  if (llvm::errorToBool(DBISymbolIDToSymbols.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBITrigramToSymbolID = lmdb::DBI::open(
      *Txn, LMDBIndex::DB_TRIGRAM_TO_SYMBOLID, MDB_CREATE | MDB_DUPSORT);
  if (llvm::errorToBool(DBITrigramToSymbolID.takeError()))
    return nullptr;
  llvm::Expected<lmdb::DBI> DBIScopeToSymbolID = lmdb::DBI::open(
      *Txn, LMDBIndex::DB_SCOPE_TO_SYMBOLID, MDB_CREATE | MDB_DUPSORT);
  if (llvm::errorToBool(DBIScopeToSymbolID.takeError()))
    return nullptr;

  // Commit the changes to storage in one go
  Err = Txn->commit();
  if (llvm::errorToBool(std::move(Err)))
    return nullptr;

  auto LMDBIndexPtr = llvm::make_unique<LMDBIndex>();
  LMDBIndexPtr->DBEnv = std::move(*Env);
  LMDBIndexPtr->IDAllocator = std::move(*IDAllocator);
  LMDBIndexPtr->DBIRecords = std::move(*DBIRecords);
  LMDBIndexPtr->DBIFilePathToFileInfo = std::move(*DBIFilePathToFileInfo);
  LMDBIndexPtr->DBIFileIDToSymbolRecs = std::move(*DBIFileIDToSymbolRecs);
  LMDBIndexPtr->DBIFileIDToRefRecs = std::move(*DBIFileIDToRefRecs);
  LMDBIndexPtr->DBISymbolIDToSymbolRecords =
      std::move(*DBISymbolIDToSymbolRecords);
  LMDBIndexPtr->DBISymbolIDToRefRecords = std::move(*DBISymbolIDToRefRecords);
  LMDBIndexPtr->DBISymbolIDToSymbols = std::move(*DBISymbolIDToSymbols);
  LMDBIndexPtr->DBITrigramToSymbolID = std::move(*DBITrigramToSymbolID);
  LMDBIndexPtr->DBIScopeToSymbolID = std::move(*DBIScopeToSymbolID);
  return LMDBIndexPtr;
}

llvm::Optional<FileDigest> LMDBIndex::getFileDigest(llvm::StringRef FilePath) {
  lmdb::Txn Txn;
  {
    auto Expected = lmdb::Txn::begin(DBEnv, nullptr, MDB_RDONLY);
    if (llvm::errorToBool(Expected.takeError()))
      return {};
    Txn = std::move(*Expected);
  }

  // Current we use hashed \p FilePath as file ID.
  HashedID HashedPath = makeHashedID(FilePath);
  llvm::Optional<RecordID> FileID;
  llvm::Optional<FileDigest> Digest;

  // Remove the original file
  if (auto Err =
          foreachRecordsUnderKey(Txn, DBIFilePathToFileInfo, HashedPath,
                                 [&](const lmdb::Val &RecIDData) -> bool {
                                   FileID = *RecIDData.data<RecordID>();
                                   return false;
                                 }))
    return {};
  if (FileID) {
    auto Expected = getRecord(Txn, *FileID);
    if (llvm::errorToBool(Expected.takeError()))
      return {};
    FileInfo FI = deserializeFileInfo(toStringRef(*Expected));
    Digest = FI.Digest;
  }

  llvm::consumeError(Txn.commit());
  return Digest;
}

llvm::Error LMDBIndex::update(llvm::StringRef FilePath, FileDigest Digest,
                              const SymbolSlab *SS, const RefSlab *RS) {
  const auto TimerStart = std::chrono::high_resolution_clock::now();
  auto Err = updateFile(FilePath, Digest, SS, RS);
  const auto TimerStop = std::chrono::high_resolution_clock::now();
  const auto Duration = std::chrono::duration_cast<std::chrono::milliseconds>(
      TimerStop - TimerStart);
  log("Update of {0} took {1}. Error: {2}. Indexed ({3} symbols, {4} "
      "refs)\n",
      FilePath, Duration, Err, SS->size(), RS->numRefs());
  return Err;
}

llvm::Expected<RecordID> LMDBIndex::addRecord(lmdb::Txn &Txn,
                                              llvm::ArrayRef<uint8_t> Data) {
  RecordID RecID;
  {
    // Try to allocate a RecordID.
    auto Expected = IDAllocator.Allocate(Txn, 1);
    if (!Expected)
      return Expected.takeError();
    RecID = Expected->first;
  }

  // Now put the data into records database
  lmdb::Val D(Data);
  if (auto Err = DBIRecords.put(Txn, lmdb::Val(&RecID), D, 0))
    return std::move(Err);
  return RecID;
}

llvm::Error LMDBIndex::delRecord(lmdb::Txn &Txn, RecordID RecID) {
  // Remove data associated with \p RecID into records database
  if (auto Err = DBIRecords.del(Txn, lmdb::Val(&RecID), {}))
    return Err;
  // Free a RecordID.
  return IDAllocator.Free(Txn, RecID, 1);
}

llvm::Error LMDBIndex::updateRecord(lmdb::Txn &Txn, RecordID RecID,
                                    llvm::ArrayRef<uint8_t> Data) {
  // Overwrite data of \p RecID with \p Data
  lmdb::Val D(Data);
  return DBIRecords.put(Txn, lmdb::Val(&RecID), D, 0);
}

llvm::Expected<llvm::ArrayRef<uint8_t>> LMDBIndex::getRecord(lmdb::Txn &Txn,
                                                             RecordID RecID) {
  lmdb::Val Data;
  // Get data associated with \p RecID from records database
  if (auto Err = DBIRecords.get(Txn, &RecID, Data))
    return std::move(Err);
  return Data;
}

llvm::Error LMDBIndex::updateFile(llvm::StringRef FilePath, FileDigest Digest,
                                  const SymbolSlab *SS, const RefSlab *RS) {
  llvm::DenseSet<SymbolID> TouchedSyms;
  lmdb::Txn Txn;
  {
    auto Expected = lmdb::Txn::begin(DBEnv);
    if (!Expected)
      return Expected.takeError();
    Txn = std::move(*Expected);
  }
  auto RemoveSymbols = [this, &Txn,
                        &TouchedSyms](RecordID FileID) -> llvm::Error {
    llvm::Error E2 = llvm::Error::success();
    llvm::consumeError(std::move(E2));
    // Delete all the \p SS related to this file
    if (auto Err = foreachRecordsUnderKey(
            Txn, DBIFileIDToSymbolRecs, makeRecordIDKey(FileID),
            [&](const lmdb::Val &Data) -> bool {
              RecordID RecID = *Data.data<RecordID>();
              SymbolID ID;
              std::string Name, Scope;
              {
                auto Expected = getRecord(Txn, RecID);
                E2 = Expected.takeError();
                if (E2)
                  return false;
                // Only non StringRef members of S will be valid after
                // delRecord()
                Symbol S = deserializeSymbol(toStringRef(*Expected));
                ID = S.ID;
                Name = S.Name;
                Scope = S.Scope;
              }

              E2 = delRecord(Txn, RecID);
              if (E2)
                return false;
              // Delete SymbolID -> Symbol RecordID associations
              E2 = DBISymbolIDToSymbolRecords.del(Txn, ID.raw(), {&RecID});
              if (E2)
                return false;

              TouchedSyms.insert(ID);
              return true;
            }))
      return Err;
    if (E2)
      return E2;
    // Delete FileID -> Symbol RecordID associations in batch
    if (auto Err = llvm::handleErrors(
            DBIFileIDToSymbolRecs.del(Txn, &FileID, llvm::None),
            [](std::unique_ptr<lmdb::DBError> ErrorInfo) -> llvm::Error {
              if (ErrorInfo->returnCode() != MDB_NOTFOUND)
                return llvm::Error(std::move(ErrorInfo));
              return llvm::Error::success();
            }))
      return Err;
    return llvm::Error::success();
  };
  auto RemoveRefs = [this, &Txn](RecordID FileID) -> llvm::Error {
    llvm::Error E2 = llvm::Error::success();
    llvm::consumeError(std::move(E2));
    // Delete all the \p RS related to this file
    if (auto Err = foreachRecordsUnderKey(
            Txn, DBIFileIDToRefRecs, makeRecordIDKey(FileID),
            [&](const lmdb::Val &Data) -> bool {
              RecordID RecID = *Data.data<RecordID>();
              auto Expected = getRecord(Txn, RecID);
              E2 = Expected.takeError();
              if (E2)
                return false;
              SymbolID ID =
                  deserializeSymbolIDRef(toStringRef(*Expected)).first;
              E2 = delRecord(Txn, RecID);
              if (E2)
                return false;
              // Delete SymbolID -> SymbolID:Ref RecordID associations
              E2 = DBISymbolIDToRefRecords.del(Txn, ID.raw(), {&RecID});
              if (E2)
                return false;
              return true;
            }))
      return Err;
    if (E2)
      return E2;
    // Delete FileID -> SymbolID:Ref RecordID associations in batch
    if (auto Err = llvm::handleErrors(
            DBIFileIDToRefRecs.del(Txn, &FileID, llvm::None),
            [](std::unique_ptr<lmdb::DBError> ErrorInfo) -> llvm::Error {
              if (ErrorInfo->returnCode() != MDB_NOTFOUND)
                return llvm::Error(std::move(ErrorInfo));
              return llvm::Error::success();
            }))
      return Err;
    return llvm::Error::success();
  };
  auto AddSymbol = [this, &Txn, &TouchedSyms](
                       RecordID FileID, const SymbolSlab *SS) -> llvm::Error {
    for (auto &I : *SS) {
      auto RecID =
          addRecord(Txn, llvm::arrayRefFromStringRef(serializeSymbol(I)));
      if (!RecID)
        return RecID.takeError();
      // Insert SymbolID to Symbol RecordID association
      auto Err = DBISymbolIDToSymbolRecords.put(Txn, I.ID.raw(), &*RecID, 0);
      if (Err)
        return Err;
      // Insert FileID to Symbol RecordID association
      Err = DBIFileIDToSymbolRecs.put(Txn, &FileID, &*RecID, 0);
      if (Err)
        return Err;
      TouchedSyms.insert(I.ID);
    }
    return llvm::Error::success();
  };
  auto AddRefs = [this, &Txn](RecordID FileID,
                              const RefSlab *RS) -> llvm::Error {
    lmdb::Cursor FIDCursor;
    {
      auto Expected = lmdb::Cursor::open(Txn, DBIFileIDToRefRecs);
      if (!Expected)
        return Expected.takeError();
      FIDCursor = std::move(*Expected);
    }
    for (auto &I : *RS) {
      lmdb::Cursor SIDCursor;
      {
        auto Expected = lmdb::Cursor::open(Txn, DBISymbolIDToRefRecords);
        if (!Expected)
          return Expected.takeError();
        SIDCursor = std::move(*Expected);
      }
      for (auto &K : I.second) {
        auto RecID = addRecord(
            Txn, llvm::arrayRefFromStringRef(serializeSymbolIDRef(I.first, K)));
        if (!RecID)
          return RecID.takeError();
        // Insert SymbolID to SymbolID|Ref record association
        auto Err = SIDCursor.put(I.first.raw(), &*RecID, 0);
        if (Err)
          return Err;
        // Insert FileID to SymbolID|Ref record association
        Err = FIDCursor.put(&FileID, &*RecID, 0);
        if (Err)
          return Err;
      }
    }
    return llvm::Error::success();
  };
  auto RemoveSymbolFromStore = [this, &Txn](SymbolID ID) -> llvm::Error {
    lmdb::Val V;
    auto Err = DBISymbolIDToSymbols.get(Txn, ID.raw(), V);
    if (Err)
      return Err;
    Symbol S = deserializeSymbol(V);
    std::vector<Token> Trigrams = generateIdentifierTrigrams(S.Name);
    // Remove trigram tokens corresponding to the Symbol
    for (auto &I : Trigrams) {
      Err = DBITrigramToSymbolID.del(Txn, I.Data, {ID.raw()});
      if (Err)
        return Err;
    }
    if (S.Scope.size()) {
      // In case the Symbol has scope, remove scope tokens corresponding to the
      // Symbol
      Err = DBIScopeToSymbolID.del(Txn, S.Scope, {ID.raw()});
      if (Err)
        return Err;
    }
    // Remove the corresponding Symbol from Symbols database
    return DBISymbolIDToSymbols.del(Txn, ID.raw(), llvm::None);
  };
  auto UpdateSymbolToStore = [this, &Txn](Symbol &S) -> llvm::Error {
    // Generate trigram tokens corresponding to the unqualified name of
    // the symbol. Then, insert trigram tokens to SymbolID associations.
    std::vector<Token> Trigrams = generateIdentifierTrigrams(S.Name);
    for (auto &TI : Trigrams) {
      auto Err = llvm::handleErrors(
          DBITrigramToSymbolID.put(Txn, TI.Data, S.ID.raw(), MDB_NODUPDATA),
          [](std::unique_ptr<lmdb::DBError> ErrorInfo) -> llvm::Error {
            if (ErrorInfo->returnCode() != MDB_KEYEXIST)
              return llvm::Error(std::move(ErrorInfo));
            return llvm::Error::success();
          });
      if (Err)
        return Err;
    }
    if (S.Scope.size()) {
      // In case the symbol has parent scope, insert unqualified name to
      // qualified name association.
      auto Err = llvm::handleErrors(
          DBIScopeToSymbolID.put(Txn, S.Scope, S.ID.raw(), MDB_NODUPDATA),
          [](std::unique_ptr<lmdb::DBError> ErrorInfo) -> llvm::Error {
            if (ErrorInfo->returnCode() != MDB_KEYEXIST)
              return llvm::Error(std::move(ErrorInfo));
            return llvm::Error::success();
          });
      if (Err)
        return Err;
    }
    // Update the corresponding Symbol in Symbols database
    return DBISymbolIDToSymbols.put(Txn, S.ID.raw(), serializeSymbol(S), 0);
  };

  // Current we use hashed \p FilePath as file ID.
  HashedID HashedPath = makeHashedID(FilePath);
  llvm::Optional<RecordID> FileID;

  // Find the File ID of the original file
  if (auto Err =
          foreachRecordsUnderKey(Txn, DBIFilePathToFileInfo, HashedPath,
                                 [&](const lmdb::Val &RecIDData) -> bool {
                                   FileID = *RecIDData.data<RecordID>();
                                   return false;
                                 }))
    return Err;
  if (FileID) {
    FileInfo PrevFI;
    {
      auto Expected = getRecord(Txn, *FileID);
      if (!Expected)
        return Expected.takeError();
      PrevFI = deserializeFileInfo(toStringRef(*Expected));
    }

    // Delete all the \p SS related to this file
    if (auto Err = RemoveSymbols(*FileID))
      return Err;

    // Delete all the \p RS related to this file
    if (auto Err = RemoveRefs(*FileID))
      return Err;

    // IF neither RefSlab nor SymbolSlab is given, that implies the file is
    // removed.
    if (!RS && !SS) {
      auto Err = DBIFilePathToFileInfo.del(
          Txn, llvm::ArrayRef<uint8_t>(HashedPath), {&*FileID});
      if (Err)
        return Err;
      Err = delRecord(Txn, *FileID);
      if (Err)
        return Err;
    }
  }
  if (!RS && !SS)
    return Txn.commit();

  // If \p FileInfo for given file does not exist, allocate a new RecordID for
  // FileInfo of this file and associate the hashed file path with RecordID
  // of the FileInfo of this file
  if (!FileID) {
    auto Expected = IDAllocator.Allocate(Txn, 1);
    if (!Expected)
      return Expected.takeError();
    FileID = Expected->first;
    if (auto Err = DBIFilePathToFileInfo.put(
            Txn, llvm::ArrayRef<uint8_t>(HashedPath), &*FileID, 0))
      return Err;
  }

  // Generate FileInfo for this file, and insert SS, RS into records
  // database and build corresponding Key-RecordID association
  FileInfo FI;
  FI.Digest = Digest;
  if (SS)
    if (auto Err = AddSymbol(*FileID, SS))
      return Err;
  if (RS)
    if (auto Err = AddRefs(*FileID, RS))
      return Err;

  // Iterate the touched Symbols and see whether the corresponding Symbol in
  // Symbols database should be updated or removed
  for (auto &I : TouchedSyms) {
    lmdb::Cursor Cursor;
    {
      auto Expected = lmdb::Cursor::open(Txn, DBISymbolIDToSymbolRecords);
      if (auto Err = Expected.takeError())
        return Err;
      Cursor = std::move(*Expected);
    }

    llvm::BumpPtrAllocator MemPool;
    llvm::StringSaver Strings(MemPool);
    llvm::Error E2 = llvm::Error::success();
    llvm::consumeError(std::move(E2));

    // Check if the SymbolID still exists. If it does not, remove the
    // inverted index and scope index related to this symbol. If it does,
    // merge the symbol records corresponding to the same SymbolID to provide
    // a Symbol for query.

    llvm::Optional<Symbol> Sym;
    if (auto Err = Cursor.foreachKey(
            I.raw(), [&](const lmdb::Val &, const lmdb::Val &V) {
              auto RecID = *V.data<RecordID>();
              auto Data = getRecord(Txn, RecID);
              if (!Data) {
                E2 = Data.takeError();
                return lmdb::IteratorControl::Stop;
              }
              Symbol S = deserializeSymbol(llvm::toStringRef(*Data));
              OwnSymbol(S, Strings);
              if (!Sym)
                Sym = S;
              else
                Sym = mergeSymbol(*Sym, S);
              return lmdb::IteratorControl::Continue;
            }))
      return Err;
    if (E2)
      return E2;
    if (!Sym) {
      // No Symbol records corresponding to given SymbolID exists, so clean up
      // the trigram inverted index and scope index
      if (auto Err = RemoveSymbolFromStore(I))
        return Err;
    } else {
      // Update the Symbol in Symbols database
      if (auto Err = UpdateSymbolToStore(*Sym))
        return Err;
    }
  }

  // Insert the generated FileInfo into records database
  std::string FIStream = serializeFileInfo(FI);
  if (auto Err =
          updateRecord(Txn, *FileID, llvm::arrayRefFromStringRef(FIStream)))
    return Err;

  // The final step is to commit all the changes made
  return Txn.commit();
}

llvm::Optional<Symbol> LMDBIndex::GetSymbol(lmdb::Txn &Txn, SymbolID ID,
                                            llvm::StringSaver &Strings) {
  lmdb::Val V;
  if (llvm::errorToBool(DBISymbolIDToSymbols.get(Txn, ID.raw(), V)))
    return llvm::None;
  Symbol S = deserializeSymbol(V);
  OwnSymbol(S, Strings);
  return S;
};

bool LMDBSymbolIndex::fuzzyFind(
    const FuzzyFindRequest &Req,
    llvm::function_ref<void(const Symbol &)> Callback) const {
  lmdb::Txn Txn;
  {
    auto Expected = lmdb::Txn::begin(DBIndex->DBEnv, nullptr, MDB_RDONLY);
    if (!Expected) {
      llvm::consumeError(Expected.takeError());
      return false;
    }
    Txn = std::move(*Expected);
  }

  Corpus CorpusSet(-1ull);
  std::vector<std::unique_ptr<Iterator>> Criteria;
  FuzzyMatcher Filter(Req.Query);
  bool More = !Req.Query.empty() && Req.Query.size() < 3;

  std::vector<std::vector<DocID>> Toks;
  std::vector<std::unique_ptr<Iterator>> TrigramIterators;
  for (const auto &I : generateQueryTrigrams(Req.Query)) {
    lmdb::Cursor Cursor;
    {
      auto Expected = lmdb::Cursor::open(Txn, DBIndex->DBITrigramToSymbolID);
      if (llvm::errorToBool(Expected.takeError()))
        return false;
      Cursor = std::move(*Expected);
    }
    std::vector<DocID> SymbolIDs;
    if (llvm::errorToBool(Cursor.foreachKey(
            I.Data, [&SymbolIDs](const lmdb::Val &, const lmdb::Val &V) {
              SymbolIDs.push_back(*V.data<DocID>());
              return lmdb::IteratorControl::Continue;
            })))
      return false;
    llvm::sort(SymbolIDs, std::less<DocID>());
    Toks.emplace_back(std::move(SymbolIDs));
    TrigramIterators.emplace_back(
        llvm::make_unique<VectorIterator>(Toks.back()));
  }
  Criteria.push_back(CorpusSet.intersect(move(TrigramIterators)));

  std::vector<std::unique_ptr<Iterator>> ScopeIterators;
  for (const auto &I : Req.Scopes) {
    lmdb::Cursor Cursor;
    {
      auto Expected = lmdb::Cursor::open(Txn, DBIndex->DBIScopeToSymbolID);
      if (llvm::errorToBool(Expected.takeError()))
        return false;
      Cursor = std::move(*Expected);
    }
    std::vector<DocID> SymbolIDs;
    if (llvm::errorToBool(Cursor.foreachKey(
            I, [&SymbolIDs](const lmdb::Val &, const lmdb::Val &V) {
              SymbolIDs.push_back(*V.data<DocID>());
              return lmdb::IteratorControl::Continue;
            })))
      return false;
    if (SymbolIDs.size()) {
      llvm::sort(SymbolIDs, std::less<DocID>());
      Toks.emplace_back(std::move(SymbolIDs));
      ScopeIterators.emplace_back(
          llvm::make_unique<VectorIterator>(Toks.back()));
    }
  }
  if (Req.AnyScope)
    ScopeIterators.push_back(
        CorpusSet.boost(CorpusSet.all(), ScopeIterators.empty() ? 1.0 : 0.2));
  Criteria.push_back(CorpusSet.unionOf(move(ScopeIterators)));

  using IDAndScore = std::pair<Symbol, float>;
  auto Compare = [](const IDAndScore &LHS, const IDAndScore &RHS) {
    return LHS.second > RHS.second;
  };

  auto Root = CorpusSet.intersect(move(Criteria));
  if (Req.Limit)
    Root = CorpusSet.limit(move(Root), *Req.Limit * 100);
  TopN<IDAndScore, decltype(Compare)> Top(
      Req.Limit ? *Req.Limit : std::numeric_limits<size_t>::max(), Compare);
  llvm::BumpPtrAllocator MemPool;
  llvm::StringSaver Strings(MemPool);
  for (; !Root->reachedEnd(); Root->advance()) {
    auto SymID =
        SymbolID::fromRaw(llvm::toStringRef(makeRecordIDKey(Root->peek())));
    auto Sym = DBIndex->GetSymbol(Txn, SymID, Strings);
    assert(Sym);
    auto Score = Filter.match(Sym->Name);
    if (Score)
      More |= Top.push({*Sym, *Score * quality(*Sym)});
  }
  for (const auto &I : std::move(Top).items()) {
    Callback(I.first);
  }

  llvm::consumeError(Txn.commit());
  return More;
}

void LMDBSymbolIndex::lookup(
    const LookupRequest &Req,
    llvm::function_ref<void(const Symbol &)> Callback) const {
  lmdb::Txn Txn;
  {
    auto Expected = lmdb::Txn::begin(DBIndex->DBEnv, nullptr, MDB_RDONLY);
    if (!Expected) {
      llvm::consumeError(Expected.takeError());
      return;
    }
    Txn = std::move(*Expected);
  }

  for (auto &ID : Req.IDs) {
    llvm::BumpPtrAllocator MemPool;
    llvm::StringSaver Strings(MemPool);
    if (auto Sym = DBIndex->GetSymbol(Txn, ID, Strings))
      Callback(*Sym);
  }

  llvm::consumeError(Txn.commit());
}

void LMDBSymbolIndex::refs(
    const RefsRequest &Req,
    llvm::function_ref<void(const Ref &)> Callback) const {
  lmdb::Txn Txn;
  {
    auto Expected = lmdb::Txn::begin(DBIndex->DBEnv, nullptr, MDB_RDONLY);
    if (!Expected) {
      llvm::consumeError(Expected.takeError());
      return;
    }
    Txn = std::move(*Expected);
  }

  for (auto &ID : Req.IDs) {
    // Look up all RecordIDs containing Ref for the SymbolID
    auto Err = foreachRecordsUnderKey(
        Txn, DBIndex->DBISymbolIDToRefRecords,
        llvm::arrayRefFromStringRef(ID.raw()),
        [&](const lmdb::Val &RecIDData) -> bool {
          auto SymbolData =
              DBIndex->getRecord(Txn, *RecIDData.data<RecordID>());
          if (!SymbolData)
            return false;
          Callback(
              deserializeSymbolIDRef(llvm::toStringRef(*SymbolData)).second);
          return true;
        });
    if (Err)
      llvm::consumeError(std::move(Err));
  }

  llvm::consumeError(Txn.commit());
}

} // namespace dbindex
} // namespace clangd
} // namespace clang
